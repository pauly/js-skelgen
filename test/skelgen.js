/**
 * generated by node,/home/paul/vows-skelgen/skelgen.js,lib/skelgen.js,--output,test/skelgen.js
 * https://github.com/pauly/vows-skelgen
 * Wed Jan 29 2014 13:10:55 GMT+0000 (UTC)
 */

var Mocha = require( 'mocha' );
var mocha = new Mocha( { ui: 'exports', reporter: 'list' } );
var assert = require( 'assert' );
var file = './../lib/skelgen.js';
var skelgen = require( file );

module.exports = {
  'skelgen.sanitise': {
    'handles good input': function ( ) {
      assert.deepEqual( skelgen.sanitise( 'foo' ), 'foo' );
      assert.deepEqual( skelgen.sanitise( 66 ), '66' );
      assert.deepEqual( skelgen.sanitise( 'foo \'bar\'' ), 'foo bar' );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.sanitise( 'foo' );
          skelgen.sanitise( 66 );
          skelgen.sanitise( undefined );
          skelgen.sanitise( null );
          skelgen.sanitise( [] );
          skelgen.sanitise( {} );
          skelgen.sanitise( new Date( ) );
          skelgen.sanitise( function ( ) { } );
        }
      );
    }
  },
  'skelgen.uninstantiate': {
    'handles good input': function ( ) {
      assert.deepEqual( skelgen.uninstantiate( 'foo' ), 'foo' );
      assert.deepEqual( skelgen.uninstantiate( 66 ), '66' );
      assert.deepEqual( skelgen.uninstantiate( 'new foo( )' ), 'foo' );
      assert.deepEqual( skelgen.uninstantiate( 'new foo()' ), 'foo' );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.uninstantiate( 'foo' );
          skelgen.uninstantiate( 66 );
          skelgen.uninstantiate( undefined );
          skelgen.uninstantiate( null );
          skelgen.uninstantiate( [] );
          skelgen.uninstantiate( {} );
          skelgen.uninstantiate( new Date( ) );
          skelgen.uninstantiate( function ( ) { } );
        }
      );
    }
  },
  'skelgen.baseName': {
    'handles good input': function ( ) {
      assert.deepEqual( skelgen.baseName( 'foo/bar.js' ), 'bar' );
      assert.deepEqual( skelgen.baseName( 'foo/bar' ), 'bar' );
      assert.deepEqual( skelgen.baseName( 'foo.js' ), 'foo' );
      assert.deepEqual( skelgen.baseName( 'foo' ), 'foo' );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.baseName( 'foo' );
          skelgen.baseName( 66 );
          skelgen.baseName( undefined );
          skelgen.baseName( null );
          skelgen.baseName( [] );
          skelgen.baseName( {} );
          skelgen.baseName( new Date( ) );
          skelgen.baseName( function ( ) { } );
        }
      );
    }
  },
  'skelgen.writeTests': {
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.writeTests( 'foo','foo','foo' );
          skelgen.writeTests( 66,66,66 );
          skelgen.writeTests( undefined,undefined,undefined );
          skelgen.writeTests( null,null,null );
          skelgen.writeTests( [],[],[] );
          skelgen.writeTests( {},{},{} );
          skelgen.writeTests( new Date( ),new Date( ),new Date( ) );
          skelgen.writeTests( function ( ) { },function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen.stringify': {
    'handles good input': function ( ) {
      assert.deepEqual( skelgen.stringify( 66 ), '66' );
      assert.deepEqual( skelgen.stringify( 'foo' ), '\'foo\'' );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.stringify( 'foo' );
          skelgen.stringify( 66 );
          skelgen.stringify( undefined );
          skelgen.stringify( null );
          skelgen.stringify( [] );
          skelgen.stringify( {} );
          skelgen.stringify( new Date( ) );
          skelgen.stringify( function ( ) { } );
        }
      );
    }
  },
  'skelgen.map': {
    'handles good input': function ( ) {
      assert.deepEqual( skelgen.map( [ ], 'foo' ), [ 'foo' ] );
      assert.deepEqual( skelgen.map( [ 1 ], 'foo' ), [ 'foo' ] );
      assert.deepEqual( skelgen.map( [ 'bar' ], 'foo' ), [ 'foo' ] );
      var expected = [ 'foo', 'foo', 'foo' ];
      assert.deepEqual( skelgen.map( [ 1, 2, 3 ], 'foo' ), expected );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.map( 'foo','foo' );
          skelgen.map( 66,66 );
          skelgen.map( undefined,undefined );
          skelgen.map( null,null );
          skelgen.map( [],[] );
          skelgen.map( {},{} );
          skelgen.map( new Date( ),new Date( ) );
          skelgen.map( function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen.asyncTests': {
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.asyncTests( 'foo','foo','foo' );
          skelgen.asyncTests( 66,66,66 );
          skelgen.asyncTests( undefined,undefined,undefined );
          skelgen.asyncTests( null,null,null );
          skelgen.asyncTests( [],[],[] );
          skelgen.asyncTests( {},{},{} );
          skelgen.asyncTests( new Date( ),new Date( ),new Date( ) );
          skelgen.asyncTests( function ( ) { },function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen.commentBefore': {
    'handles good input': function ( ) {
      assert.deepEqual( skelgen.commentBefore( 'foo', 'bar' ), null );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.commentBefore( 'foo','foo' );
          skelgen.commentBefore( 66,66 );
          skelgen.commentBefore( undefined,undefined );
          skelgen.commentBefore( null,null );
          skelgen.commentBefore( [],[] );
          skelgen.commentBefore( {},{} );
          skelgen.commentBefore( new Date( ),new Date( ) );
          skelgen.commentBefore( function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen.assertsFrom': {
    'handles good input': function ( ) {
      var expected = [ [ '1', '==', '1' ] ];
      assert.deepEqual( skelgen.assertsFrom( ' * @assert (1) == 1' ), expected );
      expected = [ [ '2', '===', '2' ] ];
      assert.deepEqual( skelgen.assertsFrom( ' * @assert (2) === 2' ), expected );
      expected = [ [ '3', '==', '3' ] ];
      assert.deepEqual( skelgen.assertsFrom( ' * @assert ( 3 ) == 3' ), expected );
      expected = [ [ '4', '==', '4' ], [ '5', '==', '5' ], ];
      assert.deepEqual( skelgen.assertsFrom( ' * @assert ( 4) == 4\n * @assert (5 ) == 5' ), expected );
      expected = [ [ '\'seven\'', '==', '\'seven\'' ] ];
      assert.deepEqual( skelgen.assertsFrom( ' * @assert (\'seven\') == \'seven\'' ), expected );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.assertsFrom( 'foo' );
          skelgen.assertsFrom( 66 );
          skelgen.assertsFrom( undefined );
          skelgen.assertsFrom( null );
          skelgen.assertsFrom( [] );
          skelgen.assertsFrom( {} );
          skelgen.assertsFrom( new Date( ) );
          skelgen.assertsFrom( function ( ) { } );
        }
      );
    }
  },
  'skelgen.fixturesFrom': {
    'handles good input': function ( ) {
      var expected = [ './foo.js', '../foo/bar.js' ];
      assert.deepEqual( skelgen.fixturesFrom( ' * @fixture ./foo.js\n * @fixture ../foo/bar.js ' ), expected );
    },
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.fixturesFrom( 'foo' );
          skelgen.fixturesFrom( 66 );
          skelgen.fixturesFrom( undefined );
          skelgen.fixturesFrom( null );
          skelgen.fixturesFrom( [] );
          skelgen.fixturesFrom( {} );
          skelgen.fixturesFrom( new Date( ) );
          skelgen.fixturesFrom( function ( ) { } );
        }
      );
    }
  },
  'skelgen.goodInputTests': {
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.goodInputTests( 'foo','foo' );
          skelgen.goodInputTests( 66,66 );
          skelgen.goodInputTests( undefined,undefined );
          skelgen.goodInputTests( null,null );
          skelgen.goodInputTests( [],[] );
          skelgen.goodInputTests( {},{} );
          skelgen.goodInputTests( new Date( ),new Date( ) );
          skelgen.goodInputTests( function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen._dummyAsyncMethod': {
    'handles fixture fixture/_dummyAsyncMethod.js': function ( ) {
        var file = __dirname + '/fixture/_dummyAsyncMethod.js';
        var fixture = require( file );
        skelgen._dummyAsyncMethod( fixture.param, function ( err, result ) {
        var file = __dirname + '/fixture/_dummyAsyncMethod.js';
        var fixture = require( file );
        assert.deepEqual( err, fixture.callback.err );
        assert.deepEqual( result, fixture.callback.result );
      } );
    },
    'handles malformed input': {
      'handles foo': function ( done ) {
        skelgen._dummyAsyncMethod( 'foo', function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles 66': function ( done ) {
        skelgen._dummyAsyncMethod( 66, function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles undefined': function ( done ) {
        skelgen._dummyAsyncMethod( undefined, function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles null': function ( done ) {
        skelgen._dummyAsyncMethod( null, function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles []': function ( done ) {
        skelgen._dummyAsyncMethod( [], function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles {}': function ( done ) {
        skelgen._dummyAsyncMethod( {}, function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles new Date( )': function ( done ) {
        skelgen._dummyAsyncMethod( new Date( ), function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      },
      'handles function ( ) { }': function ( done ) {
        skelgen._dummyAsyncMethod( function ( ) { }, function ( err, result ) {
          assert.ok( true );
          done( );
        } );
      }
    }
  },
  'skelgen.goodInputTestsAsync': {
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.goodInputTestsAsync( 'foo','foo','foo' );
          skelgen.goodInputTestsAsync( 66,66,66 );
          skelgen.goodInputTestsAsync( undefined,undefined,undefined );
          skelgen.goodInputTestsAsync( null,null,null );
          skelgen.goodInputTestsAsync( [],[],[] );
          skelgen.goodInputTestsAsync( {},{},{} );
          skelgen.goodInputTestsAsync( new Date( ),new Date( ),new Date( ) );
          skelgen.goodInputTestsAsync( function ( ) { },function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen.syncTests': {
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.syncTests( 'foo','foo','foo' );
          skelgen.syncTests( 66,66,66 );
          skelgen.syncTests( undefined,undefined,undefined );
          skelgen.syncTests( null,null,null );
          skelgen.syncTests( [],[],[] );
          skelgen.syncTests( {},{},{} );
          skelgen.syncTests( new Date( ),new Date( ),new Date( ) );
          skelgen.syncTests( function ( ) { },function ( ) { },function ( ) { } );
        }
      );
    }
  },
  'skelgen.generate': {
    'handles malformed input': function ( ) {
      assert.doesNotThrow(
        function ( ) {
          skelgen.generate( 'foo' );
          skelgen.generate( 66 );
          skelgen.generate( undefined );
          skelgen.generate( null );
          skelgen.generate( [] );
          skelgen.generate( {} );
          skelgen.generate( new Date( ) );
          skelgen.generate( function ( ) { } );
        }
      );
    }
  }
};
mocha.addFile( __filename );
mocha.run( function ( failures ) {
  process.exit( failures ? 1 : 0 );
} );
