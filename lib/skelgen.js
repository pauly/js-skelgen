/**
 * Vows skeleton test generator
 * https://github.com/pauly/vows-skelgen
 * 
 * @author PC <paulypopex@gmail.com>
 */

var skelgen = { };

module.exports = skelgen;

skelgen.badInputs = [ 'foo', 66, undefined, null, [ ], { }, 'new Date( )' ];

skelgen.sanitise = function ( string ) {
  return ( '' + string ).replace( /'/g, '' );
};

skelgen.baseName = function ( file ) {
  file = '' + file;
  var base = file.substring( file.lastIndexOf( '/' ) + 1 );
  if ( base.lastIndexOf( '.' ) == -1 ) {
    return base;
  }
  return base.substring( 0, base.lastIndexOf( '.' ));
};

skelgen.getFile = function ( file ) {
  file = '' + file;
  file = file.replace( process.cwd( ), './' );
  if ( /^\w/.exec( file )) {
    file = process.cwd( ) + '/' + file;
  }
  return file;
};

skelgen.writeTests = function ( method, obj ) {
  if ( ! ( obj && typeof( obj ) == 'function' )) {
    return null;
  }
  var args = [ ];
  var match = /\((.+)\)/.exec( obj.toString( ));
  if ( match && match.length > 0 ) { 
    args = match.pop( )
    .split( ',' )
    .map( function ( a ) { return a.trim( ); } );
  }
  var test = '';
  if ( args[ args.length - 1 ] == 'callback' ) {
    args.pop( );
    return skelgen.asyncTests( method, args );
  }
  return skelgen.syncTests( method, args );
};

skelgen.stringify = function ( data ) {
  if ( data === undefined ) return 'undefined';
  data = JSON.stringify( data )
    .replace( /"/g, '\'' )
    .replace( /'new Date\( \)'/, 'new Date( )' );
  return data;
};

skelgen.map = function ( args, data ) {
  if ( ! ( args instanceof Array )) return [ data ];
  var params = args.map( function ( f ) { return data; } );
  if ( params.length ) return params;
  return [ data ];
};

skelgen.asyncTests = function ( method, args ) {
  if ( ! ( args instanceof Array )) {
    args = [ ];
  }
  var test = '  \'' + skelgen.sanitise( method ) + '\': {\n';
  test += skelgen.goodInputExampleAsync( method, args ) + ',\n';
  test += '    \'handles bad input\': {\n';
  for ( var i = 0; i < skelgen.badInputs.length; i ++ ) {
    if ( i ) {
      test += ',\n';
    }
    var data = skelgen.stringify( skelgen.badInputs[ i ] );
    var params = skelgen.map( args, data );
    test += '      \'handles ' + skelgen.sanitise( data ) + '\': {\n' +
      '        topic: function ( ) {\n' +
      '          ' + method + '( ' + params + ', this.callback );\n' +
      '        },\n' +
      '        callback: function( err, result ) {\n' +
      '          // assert.equal( err, null );\n' +
      '        }\n' +
      '      }';
  }
  test += '\n    }\n' +
    '  }';
  return test;
};

skelgen.goodInputExample = function ( method, params ) {
  return '    \'handles good input\': function ( ) {\n' +
    '      // var result = ' + method + '( ' + params + ' );\n' +
    '      // var expect = { };\n' +
    '      // assert.equal( result, expect );\n' +
    '    }';
};

skelgen.goodInputExampleAsync = function ( method, params ) {
  return '    \'handles good input\': {\n' +
    '      // topic: function ( ) {\n' +
    '      //   ' + method + '( ' + params + ', this.callback );\n' +
    '      // },\n' +
    '      // callback: function( err, result ) {\n' +
    '      //   assert.equal( err, null );\n' +
    '      // },\n' +
    '    }';
};

skelgen.syncTests = function ( method, args ) {
  if ( typeof method !== 'string' ) {
    return null;
  }
  var methodInstance;
  var test;
  if ( ! ( args instanceof Array )) {
    args = [ ];
  }
  var params = args;
  params.pop( );
  test = '  \'' + skelgen.sanitise( method ) + '\': {\n';
  test += skelgen.goodInputExample( method ) + ',\n';
  test += '    \'handles bad input\': {\n';
  for ( var i = 0; i < skelgen.badInputs.length; i ++ ) {
    if ( i ) {
      test += ',\n';
    }
    var data = skelgen.stringify( skelgen.badInputs[ i ] );
    var params = skelgen.map( args, data );
    test += '      \'handles ' + skelgen.sanitise( data ) + '\': function ( ) {\n' +
      '        assert.doesNotThrow(\n' +
      '          function ( ) {\n' +
      '            ' + method + '( ' + params + ' );\n' +
      '          }\n' +
      '        );\n' +
      '      }';
  }
  test += '\n    }\n' +
    '  }';
  return test;
};

skelgen.generate = function ( ) {
  if ( ! ( process && process.argv && process.argv[2] )) {
    console.error( 'usage: node', process.argv[1], '[file] > [outputfile]' );
    console.error( '(or node', process.argv[1], '[file] | node)' );
    return null;
  }
  var file = skelgen.getFile( process.argv[2] );
  var name = skelgen.baseName( file );
  var obj = require( file );
  var funcs = obj;
  var content = '/**\n * generated by ' + process.argv[1] + '\n' +
    ' * https://github.com/pauly/vows-skelgen\n' +
    ' * @todo parse the file and use @assert rules\n' +
    ' * ' + new Date( ) + '\n */\n\n' +
    'var assert = require( \'assert\' );\n' +
    'var vows = require( \'vows\' );\n' +
    'var file = \'' + file + '\';\n' +
    'var ' + name + ' = require( file );\n\n' +
    'vows.describe( \'' + name + '\' ).addBatch( {\n';
  var gotFunctions = false;
  for ( var method in funcs ) {
    if ( funcs.hasOwnProperty( method )) {
      if ( funcs[ method ] instanceof Function ) {
        if ( gotFunctions ) {
          content += ',\n';
        }
        content += skelgen.writeTests( name + '.' + method, funcs[ method ] );
        gotFunctions = true;
      }
    }
  }
  if ( ! gotFunctions ) {
    content += skelgen.writeTests( name, obj );
    // our standard is instantiables are capitalised
    if ( /^[A-Z]/.test( name )) {
      var funcs = new obj( );
      for ( var method in funcs ) {
        if ( funcs[ method ] instanceof Function ) {
          content += ',\n';
          content += skelgen.writeTests( 'new ' + name + '( ).' + method, funcs[ method ] );
          gotFunctions = true;
        }
      }
    }
  }
  content += '\n' +
    '} ).run( );\n';
  return content;
};

